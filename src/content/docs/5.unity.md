# Unity
---

## Getting Started
Heavy can generate both Native Unity Plugins with a C# scripting interface and Unity 5 Audio Mixer Plugins. Both have the same sound output but slightly different use cases within Unity.

There are four main output targets for the Unity platform. Heavy can generate 64-bit OSX bundles, 32-bit and 64-bit Windows libraries, and of course the source code to inspect, extend, and generate your own plugins.

Windows binaries only work on Windows 8 and Windows 10. They do not work on Windows 7 but you can still build your own Windows 7 binaries from the provided source.

## Exposing Parameters
Each [exposed parameter](#2.getting_started#exposing-parameters) will automatically generate a parameter in the Unity Editor interface. These parameters can be scripted easily from elsewhere in your project.

## Native Plugins / C#
Native plugins are platform-specific native libraries. The C code generated by the patch is compiled into a binary and a C# interface is provided for access. You can attach this C# script to GameObjects within your scene in order for the sound to be spatially processed within the game world. These plugins can also act as a filter for AudioSource components when stacked together on a particular GameObject.

The below image shows an example of a Heavy generated plugin Hv_Modal_Lib Wrapper attached to a cube object.

![files](img/docs_unity_nativeplugin.png)

## Unity 5 Audio Mixer Plugins
The Audio Mixer in Unity allows you to bus audio sources for mixing, effects processing and mastering. Plugins for the Audio Mixer have the filename prefix AudioPlugin. Any that exist within the Assets folder and its subdirectories will be found by Unity. They are available to add to the mixer group, taking the patch name that is passed when generated.

In the image below the plugin Modal has been added and the parameters are shown on the right hand side.

![files](img/docs_unity_mixer.png)

For more information on exposing parameters to audio mixer plugins and accessing them in scripts check out [this Unity tutorial](https://www.youtube.com/watch?v=9tqi1aXlcpE).

## Installing a plugin
When it comes to adding plugins to your project the best practice is to create a folder within the Assets directory called Plugins. For cross-platform games it might also be useful to create platform specific subdirectories to organise each binary, for example: `Assets/Plugins/x86`, `Assets/Plugins/x64`, `Assets/Plugins/WSA/x86`, etc...

Each compiled target will contain the following files (OSX plugins have the `.bundle` extension, on Windows the extension is `.dll`):
* `Hv_{PATCH_NAME}_LibWrapper.cs` - Native Plugin C# interface
* `Hv_{PATCH_NAME}_LibWrapper` - Native Plugin dll / bundle
* `AudioPlugin_Hv_{PATCH_NAME}` - Audio Mixer Plugin dll / bundle

![files](img/docs_unity_native_loading.png)

Ensure that the platform settings have been applied to each plugin binary you wish to use and that paths are correct. `x86` corresponds to 32-bit platforms and `x86_x64` is for 64-bit platforms. Note that Android builds are specifically made for the `armeabi-v7a` architecture but will function with Unity's `ARMv7` CPU setting.

Unity has to be restarted each time the plugin file changes on the local hard disk.

## Sending Messages to Unity
Any message passed to a `[send]` or `[s]` object in the patch can be routed back into Unity. 

A C#Â delegate can be attached to the native plugin wrapper script that listens for callbacks when these messages are triggered.

The `FloatMessage` object contains a property `receiverName` to determine the origin and the `value` property contains the actual float value contained in the message. 

For example, if `0.5` is sent to `[s #toUnity]`, then `message.receiverName` will contain `#toUnity` and `message.value` will contain `0.5`.

Example:

```
public class MyMessageDelegate : MonoBehaviour {

    void Start () {
        Hv_sine_LibWrapper script = GetComponent<Hv_sine_LibWrapper>();
        script.RegisterSendHook();
        script.FloatReceivedCallback += OnFloatMessage;
    }

    void OnFloatMessage(Hv_sine_LibWrapper.FloatMessage message) {
        Debug.Log(message.receiverName + ": " + message.value);
    }
}
```


## Accessing Audio Tables

For Native Plugins, audio tables can be accessed externally from scripts in the Unity engine to set sample buffers within the patch.

There are two methods in the C# interface to facilitate this:

### From an [AudioClip](http://docs.unity3d.com/ScriptReference/AudioClip.html)
```
/**
 * Fill a table with sample data contained in the left (or mono) channel of a
 * Unity AudioClip object.
 * 
 * This function is NOT thread-safe. It is assumed that only the audio thread will
 * execute this function.
 */
void FillTableWithMonoAudioClip(string tableName, AudioClip clip)
```

Example:

```
public class MySampleLoader : MonoBehaviour {

	public AudioClip _clip; // attach a sample in the editor
	private Hv_example_LibWrapper _audio; 
	
	void Start() {
		_audio = GetComponent<Hv_example_LibWrapper>();
		// ensure that there is a table in the patch called 'sample-1'
		_audio.FillTableWithMonoAudioClip("sample-1", _clip);
	}
}
```

### From a float buffer
```
/**
 * Fill a table with sample data contained in a float array.
 * 
 * This function is NOT thread-safe. It is assumed that only the audio thread will
 * execute this function.
 */
void FillTableWithFloatBuffer(string tableName, float[] buffer)
```